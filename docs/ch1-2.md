# Unix 基础知识

内核位于环境的核心。内核的接口被称为系统调用。公用函数库位于系统调用之上。

shell 是一个特殊的应用程序，为运行其他程序提供了一个接口。

### 文件和目录

stat 和 fstat 函数返回文件属性的一个信息结构。<sys/stat.h>

### 输入输出

文件描述符是内核用于标识一个特定进程正在访问的文件的整数。当内核打开一个现有文件或创建一个新文件的时候，都会返回一个文件描述符。

每当运行一个新程序，所有 shell 都为其打开标准输入(0)、标准输出(1)、标准错误(2)。

重定向标准输入和标准输出 ./a.out < infile > outfile

函数 open, read, write, lseek, close 都提供了**不带缓冲的 IO**。这些函数都使用文件描述符。
<unistd.h>包含了很多 unix 系统服务的函数原型。比如 read, write。

标准 IO 函数为那些不带缓冲的 IO 函数提供了一个带缓冲的接口。使用标准 IO 函数无需担心如何选择最佳缓冲区大小。比如 fgets 函数，printf 函数等等。标准 IO 函数包含在<stdio.h>

### 程序和进程

unix 确保每个进程有个 Pid.调用 getpid()函数得到其进程 ID.
getpid 返回一个 pid_t 的数据类型.

进程控制的主要函数：fork, waitpid, exec(共有 7 个 exec 函数)

通常一个进程只有一个控制线程，一个进程内的所有线程共享同一个地址空间、文件描述符以及与进程相关的属性。

### 信号

可以提供一个信号捕捉函数，信号发生时调用该函数。

```c
static void sig_int(int); // 捕获函数签名

// 注册捕获函数
signal(SIGINT, sig_int);
```

当向一个进行发送信号时，我们必须是那个进程的所有者或者超级用户。

### 时间

系统基本数据类型 clock_t

### 系统调用和库函数

例如， printf 函数会调用 write 系统调用。从用户角度两者区别不大，但是在实现上两者有根本的区别。我们可以实现自己喜欢的库函数，但系统调用往往没法替换。比如 malloc 函数，我们可以定义自己的 malloc 函数，但它可能还是要使用 sbrk 系统调用。可以看出系统调用和库函数的职责不同，系统调用在内核中负责分配一块空间给进程，而 malloc 则在用户层次管理空间。

另一个区别是，系统调用提供最小接口，而库函数提供比较复杂的功能。

再举个例子， fork, exec, wait 这些都是系统调用，而 system 和 popen 都是库函数。
